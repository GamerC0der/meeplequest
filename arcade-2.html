<!DOCTYPE html>
<html>
<head>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --modal-bg: rgba(255, 255, 255, 0.95);
            --modal-text: #333;
            --modal-text-secondary: #666;
            --modal-button-bg: #4CAF50;
            --modal-button-secondary: #2196F3;
            --coin-counter-bg: rgba(0,0,0,0.7);
            --modal-overlay: rgba(0, 0, 0, 0.8);
            --modal-padding: 2rem;
            --modal-radius: 20px;
            --modal-z-index: 1000;
            --button-radius: 10px;
            --button-padding: 1rem 2rem;
            --button-font-size: 1.2rem;
        }

        .dark-mode {
            --modal-bg: rgba(33, 33, 33, 0.95);
            --modal-text: #ffffff;
            --modal-text-secondary: #cccccc;
            --modal-button-bg: #66BB6A;
            --modal-button-secondary: #42A5F5;
        }

        body {
            background: url(/static/minigame_1.png) center/cover fixed;
            margin: 0; padding: 0; min-height: 100vh;
            font-family: 'Fredoka One', cursive;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            display: none;
        }

        html {
            scrollbar-width: none;
        }

        .coin-display {
            position: absolute;
            top: 2rem;
            right: 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--coin-counter-bg);
            padding: 0.5rem 1rem;
            border-radius: 10px;
            color: white;
            font-size: 1.5rem;
            z-index: 100;
            font-family: 'Fredoka One', cursive;
        }

        .coin-icon {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
        }

        .coin-amount {
            font-weight: bold;
        }

        .dark-mode .coin-display {
            background: rgba(0,0,0,0.8);
        }


        .red-tint {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            pointer-events: none;
            z-index: 50;
            animation: red-tint-fade 0.5s ease-out;
        }

        @keyframes red-tint-fade {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const CONFIG = {
                COIN_SPAWN_INTERVAL: 500,
                COIN_FALL_SPEED: 4,
                MOVE_SPEED: 600,
                COIN_TIMEOUT: 2000,
                CROWN_THRESHOLD: 50,
                MAX_OVERLAP_ATTEMPTS: 20,
                MEEPLE_POSITION: { left: '2rem', top: '65%' }
            };

            let gameState = {
                coins: [],
                collectedCoins: 0,
                lastCoinSpawn: 0,
                gameOver: false,
                keysPressed: {},
                isJumping: false,
                jumpCount: 0,
                maxJumps: 2,
                jumpVelocity: 0,
                gravity: 0.8,
                jumpPower: -20,
                groundY: window.innerHeight * 0.65
            };

            function initializeGame() {
                const meeple = document.getElementById('player-meeple-display');
                const coinCounter = document.getElementById('coin-count');

                const selectedColor = localStorage.getItem('selectedMeepleColor') || 'blue';
                meeple.src = `/static/meeple-${selectedColor}.png`;
                document.body.classList.add('dark-mode');

                gameState.groundY = window.innerHeight * 0.65;

                Object.assign(meeple.style, {
                    left: CONFIG.MEEPLE_POSITION.left,
                    top: gameState.groundY + 'px',
                    transform: 'none',
                    transition: 'left 0.05s ease-out'
                });

                const totalCoins = parseInt(localStorage.getItem('totalCoins') || '0');
                coinCounter.textContent = gameState.collectedCoins;

                return { meeple, coinCounter };
            }

            const { meeple, coinCounter } = initializeGame();

            function checkCoinOverlap(testX, testSize) {
                const testRight = testX + testSize;
                for (const coin of gameState.coins) {
                    const coinSize = coin.isDiamond ? 96 : 48;
                    const coinRight = coin.x + coinSize;
                    if (testX < coinRight && testRight > coin.x) return true;
                }
                return false;
            }

            function getCoinType() {
                const rand = Math.random();
                if (rand < 0.05) return { type: 'red', size: 48, src: '/static/red-coin.png' };
                if (rand < 0.1) return { type: 'diamond', size: 96, src: '/static/diamond.png' };
                return { type: 'normal', size: 48, src: '/static/coin.png' };
            }

            function createCoin() {
                const coinType = getCoinType();
                const coin = createStyledElement('img', `
                    position: absolute; width: ${coinType.size}px; height: ${coinType.size}px;
                    image-rendering: pixelated; pointer-events: none; z-index: 10;
                `, { src: coinType.src });

                let randomX, attempts = 0;
                do {
                    randomX = Math.random() * (window.innerWidth - coinType.size);
                    if (++attempts > CONFIG.MAX_OVERLAP_ATTEMPTS) break;
                } while (checkCoinOverlap(randomX, coinType.size));

                coin.style.left = randomX + 'px';
                coin.style.top = `-${coinType.size}px`;

                document.body.appendChild(coin);

                return {
                    element: coin,
                    x: randomX,
                    y: -coinType.size,
                    collected: false,
                    isRedCoin: coinType.type === 'red',
                    isDiamond: coinType.type === 'diamond',
                    createdAt: Date.now(),
                    lastY: -coinType.size
                };
            }

            function updateCoinSpawning(currentTime) {
                if (currentTime - gameState.lastCoinSpawn > CONFIG.COIN_SPAWN_INTERVAL) {
                    gameState.coins.push(createCoin());
                    gameState.coins.push(createCoin());
                    gameState.lastCoinSpawn = currentTime;
                }
            }

            function checkCollision(coinRect, meepleRect) {
                return coinRect.right >= meepleRect.left &&
                       coinRect.left <= meepleRect.right &&
                       coinRect.bottom >= meepleRect.top &&
                       coinRect.top <= meepleRect.bottom;
            }

            function handleCoinCollection(coin, index) {
                if (coin.isRedCoin) {
                    gameState.gameOver = true;
                    const redTint = document.createElement('div');
                    redTint.className = 'red-tint';
                    document.body.appendChild(redTint);
                    showGameOver('You collected a red coin! Game Over!');
                } else {
                    const coinValue = coin.isDiamond ? 5 : 1;
                    gameState.collectedCoins += coinValue;
                    coinCounter.textContent = gameState.collectedCoins;
                    const currentTotal = parseInt(localStorage.getItem('totalCoins') || '0');
                    localStorage.setItem('totalCoins', (currentTotal + coinValue).toString());
                }
                collectCoin(coin, index);
            }

            function gameLoop() {
                if (gameState.gameOver) return;

                const currentTime = Date.now();
                const meepleRect = meeple.getBoundingClientRect();

                updateCoinSpawning(currentTime);

                for (let i = gameState.coins.length - 1; i >= 0; i--) {
                    const coin = gameState.coins[i];

                    if (!coin.collected) {
                        coin.lastY = coin.y;
                        coin.y += CONFIG.COIN_FALL_SPEED;
                        coin.element.style.top = coin.y + 'px';
                    }

                    const coinRect = coin.element.getBoundingClientRect();

                    if (!coin.collected && checkCollision(coinRect, meepleRect)) {
                        handleCoinCollection(coin, i);
                        continue;
                    }

                    if (currentTime - coin.createdAt > CONFIG.COIN_TIMEOUT || coin.y > window.innerHeight) {
                        coin.element.remove();
                        gameState.coins.splice(i, 1);
                    }
                }

                requestAnimationFrame(gameLoop);
            }

            gameLoop();

            function updateMovement() {
                if (gameState.gameOver) return;

                const rect = meeple.getBoundingClientRect();
                let deltaX = 0;

                if (gameState.keysPressed['a'] || gameState.keysPressed['A']) deltaX -= CONFIG.MOVE_SPEED / 60;
                if (gameState.keysPressed['d'] || gameState.keysPressed['D']) deltaX += CONFIG.MOVE_SPEED / 60;

                if (deltaX !== 0) {
                    const targetX = Math.max(0, Math.min(window.innerWidth - meeple.offsetWidth, rect.left + deltaX));
                    meeple.style.left = targetX + 'px';
                }

                const currentY = rect.top;

                if (gameState.isJumping || currentY < gameState.groundY) {
                    gameState.jumpVelocity += gameState.gravity;
                    const newY = currentY + gameState.jumpVelocity;

                    if (newY >= gameState.groundY) {
                        meeple.style.top = gameState.groundY + 'px';
                        gameState.isJumping = false;
                        gameState.jumpCount = 0;
                        gameState.jumpVelocity = 0;
                    } else {
                        meeple.style.top = newY + 'px';
                    }
                }

                requestAnimationFrame(updateMovement);
            }

            function moveMeeple(targetX) {
                if (!gameState.gameOver) {
                    meeple.style.left = (targetX - meeple.offsetWidth / 2) + 'px';
                }
            }

            function collectCoin(coin, index) {
                coin.element.remove();
                gameState.coins.splice(index, 1);
            }

            updateMovement();

            function createStyledElement(tag, styles, properties = {}) {
                const element = document.createElement(tag);
                if (styles) element.style.cssText = styles;
                Object.assign(element, properties);
                return element;
            }

            function createModalButton(text, bgColor, onClick) {
                return createStyledElement('button', `
                    background: ${bgColor}; color: white; border: none;
                    padding: var(--button-padding); border-radius: var(--button-radius);
                    font-size: var(--button-font-size); cursor: pointer; font-family: inherit;
                `, { textContent: text, onclick: onClick });
            }

            function showGameOver(message) {
                const earnedCrown = gameState.collectedCoins > CONFIG.CROWN_THRESHOLD && !localStorage.getItem('crownEarned');
                if (earnedCrown) localStorage.setItem('crownEarned', 'true');

                const controlsIndicator = document.getElementById('controls-indicator');
                if (controlsIndicator) controlsIndicator.style.display = 'none';

                const modal = createStyledElement('div', `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background: var(--modal-overlay); display: flex; justify-content: center;
                    align-items: center; z-index: var(--modal-z-index);
                    font-family: 'Fredoka One', cursive;
                `);

                const content = createStyledElement('div', `
                    background: var(--modal-bg); padding: var(--modal-padding);
                    border-radius: var(--modal-radius); text-align: center;
                    max-width: 400px; width: 90%;
                `);

                content.innerHTML = `
                    <h2 style="color: var(--modal-text); margin-bottom: 1rem;">Game Over!</h2>
                    <p style="color: var(--modal-text-secondary); margin-bottom: 1rem;">${message}</p>
                    <p style="color: var(--modal-text-secondary); margin-bottom: 1rem;">
                        Coins collected: <strong style="color: var(--modal-text);">${gameState.collectedCoins}</strong>
                    </p>
                    ${earnedCrown ? '<p style="color: #FFD700; margin-bottom: 1rem; font-weight: bold;">üéâ You earned the Crown! üéâ</p>' : ''}
                `;

                const buttonContainer = createStyledElement('div', 'display: flex; gap: 1rem; justify-content: center;');

                buttonContainer.appendChild(
                    createModalButton('Play Again', 'var(--modal-button-bg)', () => location.reload())
                );
                buttonContainer.appendChild(
                    createModalButton('Return to Hub', 'var(--modal-button-secondary)', () => window.location.href = '/play.html')
                );

                content.appendChild(buttonContainer);
                modal.appendChild(content);
                document.body.appendChild(modal);
            }

            function handleKeyEvent(event, pressed) {
                const key = event.key.toLowerCase();
                if (key === 'a' || key === 'd') {
                    gameState.keysPressed[event.key] = pressed;
                    event.preventDefault();
                } else if (key === ' ' && pressed && gameState.jumpCount < gameState.maxJumps) {
                    jump();
                    event.preventDefault();
                }
            }

            function jump() {
                gameState.isJumping = true;
                gameState.jumpCount++;
                gameState.jumpVelocity = gameState.jumpPower;
            }

            document.addEventListener('click', (event) => !gameState.gameOver && moveMeeple(event.clientX));
            document.addEventListener('keydown', (event) => handleKeyEvent(event, true));
            document.addEventListener('keyup', (event) => handleKeyEvent(event, false));
        });

            function createContextMenu(event) {
                event.preventDefault();
                const menu = document.createElement('div');
                menu.style.cssText = `
                    position: fixed;
                    top: ${event.clientY}px;
                    left: ${event.clientX}px;
                    background: #333;
                    color: #fff;
                    padding: 10px;
                    border-radius: 8px;
                    z-index: 9999;
                    font-family: 'Fredoka One', cursive;
                    font-size: 14px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
                `;

                menu.innerHTML = `
                    <div style="margin-bottom: 8px;"><b>Navigation</b></div>
                    <div onclick="window.location.href='/arcade-menu.html'" style="cursor:pointer;padding:4px 8px;border-radius:4px;margin:2px 0;">üéÆ Back to Arcade</div>
                    <div onclick="window.location.href='/index.html'" style="cursor:pointer;padding:4px 8px;border-radius:4px;margin:2px 0;">üè† Home</div>
                    <div onclick="window.location.href='/play.html'" style="cursor:pointer;padding:4px 8px;border-radius:4px;margin:2px 0;">üè∞ Hub</div>
                    <div onclick="window.location.href='/fishing-frenzy-menu.html'" style="cursor:pointer;padding:4px 8px;border-radius:4px;margin:2px 0;">üé£ Fishing</div>
                `;

                document.body.appendChild(menu);
                setTimeout(() => menu.remove(), 5000);
                document.addEventListener('click', () => menu.remove(), { once: true });
            }

            document.addEventListener('contextmenu', createContextMenu);
    </script>
    <div id="coin-counter" class="coin-display">
        <img src="/static/coin.png" alt="Coin Icon" class="coin-icon">
        <span id="coin-count" class="coin-amount">0</span>
    </div>
    <div id="controls-indicator" style="position: fixed; bottom: 2rem; right: 2rem; background: rgba(0,0,0,0.7); padding: 0.5rem 1rem; border-radius: 10px; color: white; font-size: 1rem; font-family: 'Fredoka One', cursive; z-index: 100;">
        Press <kbd style="background: rgba(255,255,255,0.2); padding: 0.2rem 0.4rem; border-radius: 3px; font-family: monospace;">SPACE</kbd> to Double Jump
    </div>
    <img id="player-meeple-display" src="/static/meeple-blue.png" alt="Your Meeple" style="position: absolute; width: 512px; height: 512px; image-rendering: pixelated;">
</body>
</html>