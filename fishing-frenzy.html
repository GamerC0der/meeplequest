<!DOCTYPE html>
<html>
<head>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        body {
            background: url(/static/beach.png) center/cover fixed;
            margin: 0; padding: 0; min-height: 100vh;
            font-family: 'Fredoka One', cursive;
            image-rendering: pixelated;
            overflow: hidden;
        }
        #display {
            position: absolute; top: 2rem; right: 2rem;
            background: rgba(0,0,0,0.8); color: white; padding: 1rem;
            border-radius: 10px; font-size: 1.5rem; z-index: 30;
        }
        #fish {
            position: absolute; font-size: 4rem; z-index: 10;
            pointer-events: none; user-select: none;
        }
    </style>
</head>
<body>
    <div id="display">Coins: <span id="score">0</span><br>Time: <span id="time">15</span></div>

    <div id="game-over-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 1000; justify-content: center; align-items: center;">
        <div style="background: url(/static/textbg.png) center/cover; padding: 2rem; border-radius: 20px; text-align: center; max-width: 400px; width: 90%; image-rendering: pixelated;">
            <h2 style="color: #8B4513; font-family: 'Georgia', serif; font-size: 2.5rem; font-weight: bold; text-transform: uppercase; margin: 0 0 1rem 0; text-shadow: 3px 3px 6px rgba(0,0,0,0.9); -webkit-text-stroke: 1px #2F1B14;">Time's Up!</h2>
            <p style="color: #2F1B14; font-family: 'Times New Roman', serif; font-size: 1.2rem; margin-bottom: 1rem;">Coins earned: <strong style="color: #FFD700;"><span id="final-coins">0</span></strong></p>
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
                <button id="play-again-btn" style="background: rgba(0,0,0,0.8); color: white; border: 2px solid #8B4513; border-radius: 8px; padding: 1rem 2rem; font-family: 'Georgia', serif; font-size: 1.2rem; font-weight: bold; cursor: pointer;">Play Again</button>
                <button id="back-to-hub-btn" style="background: rgba(0,0,0,0.8); color: white; border: 2px solid #8B4513; border-radius: 8px; padding: 1rem 2rem; font-family: 'Georgia', serif; font-size: 1.2rem; font-weight: bold; cursor: pointer;">Back to Hub</button>
            </div>
        </div>
    </div>
    <script>
        let score = 0, time = 15, gameOver = false, fishCount = 3;
        document.getElementById('score').textContent = score;
        document.getElementById('time').textContent = time;

        class FishML {
            constructor() {
                this.qTable = {};
                this.epsilon = 0.2;
                this.alpha = 0.1;
                this.gamma = 0.9;
                this.actions = [-2, -1, 0, 1, 2];
            }

            getState(cursorX, cursorY, fishX, fishY, directionX, directionY) {
                const distanceToCursor = Math.sqrt((cursorX - fishX) ** 2 + (cursorY - fishY) ** 2);
                const distanceState = Math.min(Math.floor(distanceToCursor / 50), 5);
                const directionState = Math.floor((Math.atan2(directionY, directionX) + Math.PI) / (Math.PI * 2) * 8);
                const cursorDirection = Math.atan2(cursorY - fishY, cursorX - fishX);
                const cursorState = Math.floor((cursorDirection + Math.PI) / (Math.PI * 2) * 4);
                return `${distanceState}_${directionState}_${cursorState}`;
            }

            getAction(state) {
                if (!this.qTable[state]) {
                    this.qTable[state] = {};
                    this.actions.forEach(action => {
                        this.qTable[state][action] = Math.random() * 0.1;
                    });
                }

                if (Math.random() < this.epsilon) {
                    return this.actions[Math.floor(Math.random() * this.actions.length)];
                }

                let bestAction = this.actions[0];
                let bestValue = this.qTable[state][bestAction];

                for (const action of this.actions) {
                    if ((this.qTable[state][action] || 0) > bestValue) {
                        bestValue = this.qTable[state][action] || 0;
                        bestAction = action;
                    }
                }

                return bestAction;
            }

            learn(state, action, reward, nextState) {
                if (!this.qTable[state]) this.qTable[state] = {};
                if (!this.qTable[nextState]) this.qTable[nextState] = {};

                const currentQ = this.qTable[state][action] || 0;
                const maxNextQ = Math.max(...this.actions.map(a => this.qTable[nextState][a] || 0));

                this.qTable[state][action] = currentQ + this.alpha * (reward + this.gamma * maxNextQ - currentQ);
            }
        }

        const fishes = [];
        for (let i = 0; i < fishCount; i++) {
            const fish = document.createElement('img');
            const isTrash = Math.random() < 0.15;
            fish.src = isTrash ? '/static/trash.png' : (Math.random() < 0.5 ? '/static/fish.png' : '/static/red_fish.png');
            fish.alt = isTrash ? 'Trash' : 'Fish';
            fish.style.cssText = 'position: absolute; width: 128px; height: 128px; image-rendering: pixelated; z-index: 10; pointer-events: none; user-select: none;';
            document.body.appendChild(fish);
            fishes.push({
                element: fish,
                x: Math.random() * (window.innerWidth - 160) + 50,
                y: Math.random() * (window.innerHeight - 160) + 50,
                directionX: (Math.random() - 0.5) * 4,
                directionY: (Math.random() - 0.5) * 4,
                isTrash: isTrash,
                ml: new FishML(),
                lastState: null,
                lastAction: null,
                survivalTime: 0,
                lastDecisionTime: Date.now()
            });
        }

        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;

        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function moveFishes() {
            if (gameOver) return;

            const currentTime = Date.now();

            fishes.forEach(fish => {
                fish.survivalTime++;

                if (currentTime - fish.lastDecisionTime > 500) {
                    const currentState = fish.ml.getState(mouseX, mouseY, fish.x, fish.y, fish.directionX, fish.directionY);
                    const action = fish.ml.getAction(currentState);

                    if (fish.lastState !== null && fish.lastAction !== null) {
                        let reward = fish.survivalTime * 0.01;

                        const distanceToMouse = Math.sqrt((mouseX - fish.x) ** 2 + (mouseY - fish.y) ** 2);
                        if (distanceToMouse < 100) {
                            reward -= 0.5;
                        } else if (distanceToMouse > 200) {
                            reward += 0.2;
                        }

                        const trashObjects = fishes.filter(f => f.isTrash && f !== fish);
                        let minDistanceToTrash = Infinity;
                        trashObjects.forEach(trash => {
                            const distanceToTrash = Math.sqrt((trash.x - fish.x) ** 2 + (trash.y - fish.y) ** 2);
                            minDistanceToTrash = Math.min(minDistanceToTrash, distanceToTrash);
                        });

                        if (minDistanceToTrash < 150) {
                            reward -= 0.8;
                        } else if (minDistanceToTrash > 250) {
                            reward += 0.1;
                        }

                        fish.ml.learn(fish.lastState, fish.lastAction, reward, currentState);
                    }

                    fish.lastState = currentState;
                    fish.lastAction = action;
                    fish.lastDecisionTime = currentTime;

                    const angle = Math.atan2(fish.directionY, fish.directionX);
                    const newAngle = angle + (action * Math.PI / 8);
                    const speed = Math.sqrt(fish.directionX ** 2 + fish.directionY ** 2);

                    fish.directionX = Math.cos(newAngle) * speed;
                    fish.directionY = Math.sin(newAngle) * speed;
                }

                fish.x += fish.directionX;
                fish.y += fish.directionY;

                if (fish.x <= 0 || fish.x >= window.innerWidth - 128) {
                    fish.directionX *= -1;
                    if (fish.lastState && fish.lastAction) {
                        const currentState = fish.ml.getState(mouseX, mouseY, fish.x, fish.y, fish.directionX, fish.directionY);
                        fish.ml.learn(fish.lastState, fish.lastAction, -0.3, currentState);
                    }
                }
                if (fish.y <= 0 || fish.y >= window.innerHeight - 128) {
                    fish.directionY *= -1;
                    if (fish.lastState && fish.lastAction) {
                        const currentState = fish.ml.getState(mouseX, mouseY, fish.x, fish.y, fish.directionX, fish.directionY);
                        fish.ml.learn(fish.lastState, fish.lastAction, -0.3, currentState);
                    }
                }

                fish.element.style.left = fish.x + 'px';
                fish.element.style.top = fish.y + 'px';
            });
            requestAnimationFrame(moveFishes);
        }
        moveFishes();

        setInterval(() => {
            if (!gameOver && --time <= 0) {
                gameOver = true;
                endGame();
            }
            document.getElementById('time').textContent = time;
        }, 1000);

        function endGame() {
            fishes.forEach(fish => fish.element.remove());

            const currentTotal = parseInt(localStorage.getItem('totalCoins') || '0');
            const newTotal = currentTotal + score;
            localStorage.setItem('totalCoins', newTotal.toString());

            document.getElementById('final-coins').textContent = score;
            document.getElementById('game-over-modal').style.display = 'flex';
            document.getElementById('game-over-modal').style.justifyContent = 'center';
            document.getElementById('game-over-modal').style.alignItems = 'center';

            document.getElementById('play-again-btn').addEventListener('click', () => {
                location.reload();
            });

            document.getElementById('back-to-hub-btn').addEventListener('click', () => {
                window.location.href = '/play-2.html';
            });
        }

        document.addEventListener('click', (e) => {
            if (!gameOver) {
                fishes.forEach((fish, index) => {
                    const rect = fish.element.getBoundingClientRect();
                    if (e.clientX >= rect.left && e.clientX <= rect.right &&
                        e.clientY >= rect.top && e.clientY <= rect.bottom) {
                        if (fish.isTrash) {
                            time = Math.max(0, time - 5);
                            document.getElementById('time').textContent = time;
                        } else {
                            score++;
                            document.getElementById('score').textContent = score;
                        }
                        fish.x = Math.random() * (window.innerWidth - 160) + 50;
                        fish.y = Math.random() * (window.innerHeight - 160) + 50;
                        fish.directionX = (Math.random() - 0.5) * 4;
                        fish.directionY = (Math.random() - 0.5) * 4;
                        fish.lastState = null;
                        fish.lastAction = null;
                        fish.survivalTime = 0;
                        fish.lastDecisionTime = Date.now();
                    }
                });
            }
        });
    </script>
</body>
</html>
