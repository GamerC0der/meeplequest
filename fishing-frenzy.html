<!DOCTYPE html>
<html>
<head>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            background: url(beach.png) center/cover fixed;
            margin: 0; padding: 0; min-height: 100vh; width: 100vw;
            font-family: 'Fredoka One', cursive;
            image-rendering: pixelated;
            overflow: hidden;
            position: relative;
        }
        #display {
            position: fixed; top: 2%; right: 2%;
            background: rgba(0,0,0,0.9); color: white; padding: 1rem;
            border-radius: 15px; font-size: max(14px, 1.2vw); z-index: 30;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.2);
        }
        #fish {
            position: absolute; width: 6vw; height: 6vw; min-width: 64px; min-height: 64px; z-index: 10;
            pointer-events: none; user-select: none;
        }
        #fish[alt="Trash"]::after {
            content: "TRASH";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 11;
        }
        #game-over-modal {
            display: none;
        }

        @keyframes gemPopup {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="display">Coins: <span id="score">0</span><br>Time: <span id="time">15</span></div>
    <div id="game-over-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 1000; justify-content: center; align-items: center;">
        <div style="background: url(textbg.png) center/cover; padding: 2rem; border-radius: 20px; text-align: center; max-width: 400px; width: 90%; image-rendering: pixelated;">
            <h2 style="color: #8B4513; font-family: 'Georgia', serif; font-size: 2.5rem; font-weight: bold; text-transform: uppercase; margin: 0 0 1rem 0; text-shadow: 3px 3px 6px rgba(0,0,0,0.9); -webkit-text-stroke: 1px #2F1B14;">Time's Up!</h2>
            <p style="color: #2F1B14; font-family: 'Times New Roman', serif; font-size: 1.2rem; margin-bottom: 1rem;">Coins earned: <strong style="color: #FFD700;"><span id="final-coins">0</span></strong></p>
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;">
                <button id="play-again-btn" style="background: rgba(0,0,0,0.8); color: white; border: 2px solid #8B4513; border-radius: 8px; padding: 1rem 2rem; font-family: 'Georgia', serif; font-size: 1.2rem; font-weight: bold; cursor: pointer;">Play Again</button>
                <button id="back-to-hub-btn" style="background: rgba(0,0,0,0.8); color: white; border: 2px solid #8B4513; border-radius: 8px; padding: 1rem 2rem; font-family: 'Georgia', serif; font-size: 1.2rem; font-weight: bold; cursor: pointer;">Back to Hub</button>
            </div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
        let score = 0, time = 15, gameOver = false, gemCount = 0, gemsCollected = 0;
        const screenArea = window.innerWidth * window.innerHeight;
        const fishCount = Math.max(1, Math.min(5, Math.floor(screenArea / 80000)));
        document.getElementById('score').textContent = score;
        document.getElementById('time').textContent = time;

        class FishML {
            constructor() {
                this.qTable = {};
                this.epsilon = 0.2;
                this.alpha = 0.1;
                this.gamma = 0.9;
                this.actions = [-2, -1, 0, 1, 2];
            }
            getState(cursorX, cursorY, fishX, fishY, directionX, directionY) {
                const distanceToCursor = Math.sqrt((cursorX - fishX) ** 2 + (cursorY - fishY) ** 2);
                const distanceState = Math.min(Math.floor(distanceToCursor / 50), 5);
                const directionState = Math.floor((Math.atan2(directionY, directionX) + Math.PI) / (Math.PI * 2) * 8);
                const cursorDirection = Math.atan2(cursorY - fishY, cursorX - fishX);
                const cursorState = Math.floor((cursorDirection + Math.PI) / (Math.PI * 2) * 4);
                return `${distanceState}_${directionState}_${cursorState}`;
            }
            getAction(state) {
                if (!this.qTable[state]) {
                    this.qTable[state] = {};
                    this.actions.forEach(action => {
                        this.qTable[state][action] = Math.random() * 0.1;
                    });
                }
                if (Math.random() < this.epsilon) {
                    return this.actions[Math.floor(Math.random() * this.actions.length)];
                }
                let bestAction = this.actions[0];
                let bestValue = this.qTable[state][bestAction];
                for (const action of this.actions) {
                    if ((this.qTable[state][action] || 0) > bestValue) {
                        bestValue = this.qTable[state][action] || 0;
                        bestAction = action;
                    }
                }
                return bestAction;
            }
            learn(state, action, reward, nextState) {
                if (!this.qTable[state]) this.qTable[state] = {};
                if (!this.qTable[nextState]) this.qTable[nextState] = {};
                const currentQ = this.qTable[state][action] || 0;
                const maxNextQ = Math.max(...this.actions.map(a => this.qTable[nextState][a] || 0));
                this.qTable[state][action] = currentQ + this.alpha * (reward + this.gamma * maxNextQ - currentQ);
            }
        }
        const fishes = [];
        const gemPositions = [];
        if (fishCount >= 3) {
            const numStartGems = 1;
            for (let g = 0; g < numStartGems; g++) {
                let pos;
                do {
                    pos = Math.floor(Math.random() * fishCount);
                } while (gemPositions.includes(pos));
                gemPositions.push(pos);
            }
        }

        for (let i = 0; i < fishCount; i++) {
            const fish = document.createElement('img');
            const isGem = gemPositions.includes(i);
            const rand = Math.random();
            const isTrash = rand < 0.15 && !isGem;

            if (isGem) {
                fish.src = 'diamond.png';
                fish.alt = 'Gem';
            } else {
                fish.src = isTrash ? 'trash.png' : (Math.random() < 0.5 ? 'fish.png' : 'red_fish.png');
                fish.alt = isTrash ? 'Trash' : 'Fish';
            }

            fish.style.cssText = 'position: absolute; width: 128px; height: 128px; image-rendering: pixelated; z-index: 10; pointer-events: none; user-select: none;';
            document.body.appendChild(fish);
            fishes.push({
                element: fish,
                x: Math.random() * (window.innerWidth - 160) + 50,
                y: Math.random() * (window.innerHeight - 160) + 50,
                directionX: (Math.random() - 0.5) * 4,
                directionY: (Math.random() - 0.5) * 4,
                isTrash: isTrash,
                isGem: isGem,
                ml: new FishML(),
                lastState: null,
                lastAction: null,
                survivalTime: 0,
                lastDecisionTime: Date.now()
            });
        }
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        function moveFishes() {
            if (gameOver) return;
            const currentTime = Date.now();
            fishes.forEach(fish => {
                fish.survivalTime++;
                if (currentTime - fish.lastDecisionTime > 500) {
                    const currentState = fish.ml.getState(mouseX, mouseY, fish.x, fish.y, fish.directionX, fish.directionY);
                    const action = fish.ml.getAction(currentState);
                    if (fish.lastState !== null && fish.lastAction !== null) {
                        let reward = fish.survivalTime * 0.01;
                        const distanceToMouse = Math.sqrt((mouseX - fish.x) ** 2 + (mouseY - fish.y) ** 2);
                        if (distanceToMouse < 100) {
                            reward -= 0.5;
                        } else if (distanceToMouse > 200) {
                            reward += 0.2;
                        }
                        const trashObjects = fishes.filter(f => f.isTrash && f !== fish);
                        let minDistanceToTrash = Infinity;
                        trashObjects.forEach(trash => {
                            const distanceToTrash = Math.sqrt((trash.x - fish.x) ** 2 + (trash.y - fish.y) ** 2);
                            minDistanceToTrash = Math.min(minDistanceToTrash, distanceToTrash);
                        });
                        if (minDistanceToTrash < 150) {
                            reward -= 0.8;
                        } else if (minDistanceToTrash > 250) {
                            reward += 0.1;
                        }
                        fish.ml.learn(fish.lastState, fish.lastAction, reward, currentState);
                    }
                    fish.lastState = currentState;
                    fish.lastAction = action;
                    fish.lastDecisionTime = currentTime;
                    const angle = Math.atan2(fish.directionY, fish.directionX);
                    const newAngle = angle + (action * Math.PI / 8);
                    const speed = Math.sqrt(fish.directionX ** 2 + fish.directionY ** 2);
                    fish.directionX = Math.cos(newAngle) * speed;
                    fish.directionY = Math.sin(newAngle) * speed;
                }
                fish.x += fish.directionX;
                fish.y += fish.directionY;
                if (fish.x <= 0 || fish.x >= window.innerWidth - 128) {
                    fish.directionX *= -1;
                    if (fish.lastState && fish.lastAction) {
                        const currentState = fish.ml.getState(mouseX, mouseY, fish.x, fish.y, fish.directionX, fish.directionY);
                        fish.ml.learn(fish.lastState, fish.lastAction, -0.3, currentState);
                    }
                }
                if (fish.y <= 0 || fish.y >= window.innerHeight - 128) {
                    fish.directionY *= -1;
                    if (fish.lastState && fish.lastAction) {
                        const currentState = fish.ml.getState(mouseX, mouseY, fish.x, fish.y, fish.directionX, fish.directionY);
                        fish.ml.learn(fish.lastState, fish.lastAction, -0.3, currentState);
                    }
                }
                fish.element.style.left = fish.x + 'px';
                fish.element.style.top = fish.y + 'px';
            });
            requestAnimationFrame(moveFishes);
        }
        moveFishes();
        const gameTimer = setInterval(() => {
            if (!gameOver) {
                time--;
                console.log('Timer tick: time =', time);
                document.getElementById('time').textContent = time;
                if (time <= 0) {
                    console.log('Game ending - time reached 0');
                    gameOver = true;
                    clearInterval(gameTimer);
                    endGame();
                }
            }
        }, 1000);
        function endGame() {
            fishes.forEach(fish => fish.element.remove());
            const currentTotal = parseInt(localStorage.getItem('totalCoins') || '0');
            const newTotal = currentTotal + score;
            localStorage.setItem('totalCoins', newTotal.toString());
            document.getElementById('final-coins').textContent = score;
            document.getElementById('game-over-modal').style.display = 'flex';
            document.getElementById('game-over-modal').style.justifyContent = 'center';
            document.getElementById('game-over-modal').style.alignItems = 'center';
            document.getElementById('play-again-btn').addEventListener('click', () => {
                location.reload();
            });
            document.getElementById('back-to-hub-btn').addEventListener('click', () => {
                window.location.href = 'https://gamerc0der.github.io/meeplequest/play-2.html';
            });
        }
        document.addEventListener('click', (e) => {
            if (!gameOver) {
                fishes.forEach((fish, index) => {
                    const rect = fish.element.getBoundingClientRect();
                    if (e.clientX >= rect.left && e.clientX <= rect.right &&
                        e.clientY >= rect.top && e.clientY <= rect.bottom) {
                        if (fish.isGem) {
                            gemsCollected++;
                            time = Math.min(99, time + 3);
                            score += 5;
                            document.getElementById('time').textContent = time;
                            document.getElementById('score').textContent = score;
                            showGemEarnedMessage();
                        } else if (fish.isTrash) {
                            time = Math.max(0, time - 5);
                            document.getElementById('time').textContent = time;
                        } else {
                            score++;
                            document.getElementById('score').textContent = score;
                        }
                        if (fish.isGem && gemsCollected < 2 && Math.random() < 0.01) {
                            fish.isGem = true;
                            fish.isTrash = false;
                            fish.element.src = 'diamond.png';
                            fish.element.alt = 'Gem';
                        } else {
                            fish.isGem = false;
                            const rand = Math.random();
                            const isTrash = rand < 0.15;
                            fish.isTrash = isTrash;
                            fish.element.src = isTrash ? 'trash.png' : (Math.random() < 0.5 ? 'fish.png' : 'red_fish.png');
                            fish.element.alt = isTrash ? 'Trash' : 'Fish';
                        }

                        fish.x = Math.random() * (window.innerWidth - 160) + 50;
                        fish.y = Math.random() * (window.innerHeight - 160) + 50;
                        fish.directionX = (Math.random() - 0.5) * 4;
                        fish.directionY = (Math.random() - 0.5) * 4;
                        fish.lastState = null;
                        fish.lastAction = null;
                        fish.survivalTime = 0;
                        fish.lastDecisionTime = Date.now();
                    }
                });
            }
        });

        function showGemEarnedMessage() {
            const message = document.createElement('div');
            message.textContent = 'GEM EARNED!';
            message.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, gold, #FFD700);
                color: #333;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 2rem;
                font-weight: bold;
                font-family: 'Fredoka One', cursive;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                z-index: 1000;
                animation: gemPopup 0.8s ease-out;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            `;
            document.body.appendChild(message);

            setTimeout(() => {
                message.remove();
            }, 1500);
        }
        });
document.addEventListener('contextmenu',e=>{e.preventDefault();const m=document.createElement('div');m.innerHTML=`<div style="position:fixed;top:${e.clientY}px;left:${e.clientX}px;background:#333;color:#fff;padding:10px;border-radius:8px;z-index:9999;font-family:'Fredoka One',cursive;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.5);"><div style="margin-bottom:8px;"><b>Navigation</b></div><div onclick="window.location.href='https://gamerc0der.github.io/meeplequest/fishing-frenzy-menu.html'" style="cursor:pointer;padding:4px 8px;border-radius:4px;margin:2px 0;">🎣 Back to Fishing</div><div onclick="window.location.href='https://gamerc0der.github.io/meeplequest/index.html'" style="cursor:pointer;padding:4px 8px;border-radius:4px;margin:2px 0;">🏠 Home</div><div onclick="window.location.href='https://gamerc0der.github.io/meeplequest/play.html'" style="cursor:pointer;padding:4px 8px;border-radius:4px;margin:2px 0;">🏰 Hub</div><div onclick="window.location.href='https://gamerc0der.github.io/meeplequest/arcade-menu.html'" style="cursor:pointer;padding:4px 8px;border-radius:4px;margin:2px 0;">🎮 Arcade</div>`;document.body.appendChild(m);setTimeout(()=>{m.remove()},5000);document.addEventListener('click',()=>m.remove(),{once:true})});
    </script>
</body>
</html>
